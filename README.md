# A* 寻路性能对比示例

## 示例概述
本项目展示了 A* 算法在不同实现方案下的性能表现对比，，特别是在 100×100 节点地图中对相同逻辑的实现效果。通过对同步、异步及 Job System 的优化分析，帮助开发者选择适合的方案。
--
为了让性能体现更加直观所以并没有对开放列表和关闭列表排序查找进行优化。
---

## 性能对比

### 同步方案
---
- **描述**: 主线程计算寻路。
- **性能表现**:  
  - **500个节点**: 耗时 5~3ms  (寻路加改变格子颜色)
  - **10000个节点（死路场景）**: 耗时 128ms  
- **问题**: 堵塞主线程，导致游戏帧率下降。

---

- **描述**: 使用 Job 和 Burst 优化（同步方案）。
- **性能表现**:
  - **500个节点**: 耗时 0.5ms (寻路加改变格子颜色)
  ![Job](https://github.com/user-attachments/assets/9f9a0dab-33ab-46af-a027-241e001d96b3)
  - **10000节点（死路场景）**: 耗时 30ms
  - <img width="286" alt="{D539C0EF-5704-47bd-9608-C240EBA32FE5}" src="https://github.com/user-attachments/assets/053eccd1-05c9-4c3d-8f07-9fbee3559ef5" />

- **性能提升计算**:
  - **500节点**: 性能提升约 5倍。  
  - **10000节点**: 性能提升约 91%。
  ![Job (2)](https://github.com/user-attachments/assets/23ec3514-7d26-4b22-a93b-6952b64e8f35)



---

### 异步方案 
---
- **描述**: 使用由 .NET 管理的线程池 Task开启子线程计算。
- **性能表现**:
  - **500个节点以内**: 耗时 ~ms  （下一帧完成）
    - 实际耗时受到异步延迟（下一帧执行）的影响。
  - **10000节点（死路场景）**: 耗时 130ms 
- **原因分析**:
  1.  可能数据的 L1/L2 缓存隐式拷贝导致性能下降。

---

使用 Job 系统异步调度 + Burst 优化 
- **性能表现**:(通过Profiler查看)
  - **10000节点**: 耗时 26ms
  - **408个节点**: 耗时 0.71ms 
---![Job在工作线程的执行时间](https://github.com/user-attachments/assets/cd019766-143e-459b-b2c3-f00d8f777337)
  - 不受死路影响，耗时短，减轻主线程压力。
- **优化原理**:
  - Job 系统在调度过程中对缓存命中的优化发挥了作用。
## 总结与推荐

### 适用场景
1. **主线程寻路（同步方案）**:  
   - 适合小规模寻路任务，但大规模节点时会导致严重卡顿，建议仅用于简单的休闲类小游戏。
2. **Task 异步方案**:  
   - 对小规模寻路性能表现一般，但在复杂场景（如死路）中，缓存命中问题显著影响性能，不推荐用于性能敏感场景。
3. **Job + Burst（同步或异步方案）**:  
   - 适合大规模路径寻路，特别是在复杂地图中表现尤为优异，推荐用于实际开发中的大多数场景。

---
##更新
1.加入了一个迷宫寻路小游戏 ，并且对节点进行字节对齐优化，节点结构体大小小于16字节
